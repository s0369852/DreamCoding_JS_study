// 1. async VS defer
'use strict';
// JS를 이용할 때에는 제일 윗부분에 'use strict'이라는 것을 정의 해주면 좋다. TypeScript를 이용할 때에는 전혀 선언할 필요가 없지만, 순수 바닐라 JS를 이용할 때에는 꼭 선언을 해주는 것이 좋다.
// JS는 굉장히 유연하기 때문 = 유연하다는 것은 때로는 많은 실수를 불러 일으키기도 한다. JS에서 선언되지 않은 변수의 값을 할당한다던지, 기존에 존재하는 prototype을 변경한다던지의 비상식적인 행동들은 다른 언어를 공부하고 온 개발자들에게는 미친듯한 행동일 수 있다.
// 'use strict'을 선언하는 이유는 이러한 비상식적인 행동들을 쓸 수 없게 된다. 'use strict'를 선언하지 않고 선언되지 않은 'a'라는 변수의 값을 할당하게 되면 브라우저에서는 전혀 문제가 될게 없다. 하지만 'use strict'를 선언하게 되면 에러가 발생하게 된다. 이때 에러를 없애기 위해서는 let a 라고 선언을 하게 되면 더이상 문제 될게 없다.
// 'use strict'는 조금 더 상식적인 범위 안에서 JS를 이용할 수 있게 해준다. JS엔진이 더 효율적으로 빠르게 JS를 분석할 수 있기 때문에 실행하는데 있어서 조금 더 나은 성능개선까지 기대 할 수 있다. 
// 'use strict'은 ECMAScript 5에 추가되어 있다.

console.log('HelloWorld');

let a;
a = 6;

// node.js에는 자바스크립트 엔진이 탑재가 되어있어서 브라우저 없이도 자바스크립트를 실행할 수 있다.
// node.js , 웹 API 둘다 console에 관련된 API가 있어서 둘다 된다. (동일)
// API = Application Programming Interface
// 웹 API는 자바스크립트 언어자체의 포함된게 아니라 브라우저가 제공하는 브라우저가 이해할 수 있는 함수들이다.
// console은 언어자체는 아니지만 통상적으로 많이 사용이된다.

// 브라우저 개발툴 -> Console탭에서 코드에서 작성한 메세지를 확인하거나 자바스크립트를 실행을 할 수가 있는데 이것을 이용해 동적으로 요소들을 검사하고 붙여놓고 지우고 등의 간단한 기능을 할 수 있다.

// 브라우저 개발툴 -> Source탭에서는 디버깅할때 굉장히 유용하게 사용할 수 있다. breakpoint를 걸어서 사용

// 브라우저 개발툴 -> Network탭에서는 네트워크가 어떻게 발생하고 얼마나 많은 사이즈 들의 데이터가 오고가는지 분석을 할 수 있다. performance 나 memory분석 등을 확인해 볼 수 있다.

// 자바스크립트의 공식사이트는 ecma-international.org 문법에 관련된 것이 잘 정리되어있는데 보는데 좀 난해하기 때문에 대다수는 developer.mozilla.org에서 본다.(MDN)

// async VS defer

// 1. <head> 안에 <script>가 존재할 경우
// 브라우저가 한줄 한줄 씩 분석하는 것을 parsing(파씽)이라고 한다. 이때 분석한 것을 css와 병합해서 DOM요소로 변환하게 된다.
// 한줄 한줄 분석하다가 <script>를 만나게 되면 script를 다운을 받아야 한다고 인식하기 때문에 parsing하던 것을 잠시 멈추고 필요한 자바스크립트 파일을 받는다. 이때 다운받는것을 fetching(페칭)이라고 한다. 그리고 다운이 다 받아졌으면 실행을 하는데 이것을 executing(익스커팅)라고 한다. 이 과정을 완료하면 멈췄던 parsing을 다시 시작한다. 
// 이 경우의 단점 = JS파일이 사이즈가 크고, 인터넷이 느리다면 사용자가 브라우저를 보기까지의 시간이 오래 걸린다.

// 2. <body> 안에 <script>가 존재할 경우
// 브라우저가 parsing HTML을 다하고 페이지가 준비가 되면 그제서야 fetchig JS 하고 executing JS를 하게 된다. 페이지가 사용자들에게 JS를 받기도 전에 이미 준비가 되어서 사용자가 먼저 페이지의 컨텐츠들을 볼 수 가 있다.
// 이 경우의 단점 = 사용자가 기본적인 html의 컨텐츠를 빨리 볼 수 있다는 장점이 있지만, 만약에 JS에 굉장히 의존적인 사이트라면 예를 들어 의미있는 컨텐츠가 JS이용해서 서버에 있는 데이터를 받아 온다던지, DOM요소를 꾸민다던지의 동작하는 웹사이트라면 사용자가 완전한 컨텐츠를 보려면 parsing이 다 된 페이지를 보더라도 완성도 있는 페이지를 볼 수 없고, 또 fetching, executing을 기다려야 한다. 

// 3. <head>안에 <script>의 asyn속성을 사용하는 경우
// asyn = 불리언 타입의 속성값, 선언하는것 자체만으로도 true로 설정
// 브라우저가 parsing을 하다가 asyn를 확인을 하게 되면 병렬구조로 fecting JS를 같이 하게 된다. 다운(fetching)이 완료가 되면 그때 parsing하던 것을 멈추고 다운로드 된 js파일을 실행(executing)을 하게 된다. 이렇게 실행을 다하고 나서 멈추었던 parsing을 다시 시작하게 된다.
// JS파일이 여러개인 경우 = 위에서 아래로 적은 순서대로 실행이 되는 것이 아니라 파일이 먼저 받아진 순서대로 실행이 된다. 이 경우에 만약 JS가 순서에 의존적이라면 의도한 순서대로 나타나지 않을 수도 있다.
// 이 경우의 장단점 = <body>끝에 <script>를 실행하는 것보다는 fetching이 parsing하는 동안 병렬적으로 같이 일어나기 때문에 다운로드 받는 시간을 절약할 수 있다. 하지만 JS가 html이 다 parsing을 하기 전에 실행이 되기 때문에 만약 js파일에서 query셀렉터를 이용해서 DOM요소를 조작하게 된다면 조작하려는 시점에 html에서 원하는 요소가 아직 정의가 되지 않을 수가 있다. 또 하나는 html을 parsing하는 동안에 언제든지 JS를 실행하기 위해서 멈출수가 있기 때문에 사용자가 완전한 페이지를 보는데 시간이 여전히 걸릴 수 있다는 단점이 있다.

// 4. <head>안에 <script>의 defer속성을 사용하는 경우
// parsing을 하다가 JS파일을 보면 다운(fetching)을 받자고 명령을 하게 되고 멈춤없이 parsing을 하는 동시에 다운(fetching)을 하게 된다. 그리고 parsing이 끝난 다음 마지막에 다운받은 JS를 실행(executing)하게 된다. 
// JS파일이 여러개인 경우 = parsing하는 동안 필요한 JS파일을 다 다운(fetching)받아 놓은 다음에 parsing이 끝나고 정의해논 순서대로 JS를 실행(fetching)하기 때문에 원하는대로 스크립트가 실행이 된다.

// defer이 보다 효율적이고 유용하다. 


